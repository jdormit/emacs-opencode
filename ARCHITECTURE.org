#+TITLE: Emacs OpenCode Architecture

* Overview
This project is an Emacs-native client for OpenCode. It is designed to make the
OpenCode workflow feel like a first-class Emacs experience: start or attach to a
server, open a session, and work in a dedicated buffer where prompts, responses,
and tool interactions are surfaced as a conversational log. The server remains
the source of truth; the Emacs side focuses on orchestration, UI, and a small
amount of local state needed for a smooth editing experience.

* Core Principles
- Emacs-first UX: native buffers, commands, and keybindings.
- Server-first data: OpenCode remains authoritative for sessions and messages.
- Thin orchestration: the client coordinates flows without reimplementing core
  server behavior.
- Streaming-first interaction: the UI updates incrementally as work progresses.
- Small, intentional state: cache only what improves responsiveness and display.

* High-Level Architecture
- Entry and commands
  - `opencode-run-server` normalizes a directory and registers one connection per
    directory in a hash table for reuse across commands.
  - Entry points call into the client layer using the current connection and
    open or reuse a session buffer.
- Connection lifecycle
  - A connection stores base URL, port, directory, and process handles.
  - Server startup spawns the `opencode serve` process, waits for the ready log
    line, then performs a health check before marking the connection ready.
- Transport
  - All HTTP requests flow through `opencode-request`, which builds URLs from
    the connection base URL and applies auth headers/timeouts.
- Streaming
  - SSE uses a dedicated curl process and buffer, with a small parser state
    machine that collects data lines and dispatches decoded JSON payloads.
  - Large diff payloads are intentionally skipped to keep parsing fast.
- Session UI
  - Session buffers are backed by model structs and maintain message parts,
    markers for the input region, and header rendering state.
  - Incremental updates from streaming events mutate messages and re-render
    affected regions in place.
- Models and caches
  - Sessions, messages, and parts are modeled with `cl-defstruct` and stored in
    buffer-local state for rendering.
  - Agents/providers/commands are cached on the connection for completion and
    header metadata.

* State and Caching
- The server owns session data; the client reflects it in Emacs buffers.
- Session buffers keep the current view state (messages, status, agent, input).
- Light caches (agents, providers, commands) are maintained for completion and
  header rendering, and are refreshed as needed.

* Primary Workflows
** Start and connect
- Choose a project directory and start or attach to a server.
- Validate connectivity and prepare a session buffer.

** Conversation flow
- User enters a prompt in the session buffer.
- The client dispatches the request and streams updates back into the buffer.
- The buffer maintains a readable log and provides an editable input area.

** Session navigation
- List and open existing sessions from the server.
- Reuse the most recent session buffers when possible.

** Agent and command use
- Select or cycle available agents for the session.
- Send slash-style commands when appropriate.

** Interactive prompts
- When the server needs user input (permissions or questions), the client
  requests a choice in the minibuffer and replies on the user's behalf.

* Server Interaction Model
- The client is a thin shell around the server: it issues requests, receives
  updates, and keeps the UI in sync.
- Streaming is treated as a first-class path for user feedback and progress.
- Error handling is user-visible and fail-fast to keep the UI consistent.
